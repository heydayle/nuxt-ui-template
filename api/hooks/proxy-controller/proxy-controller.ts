/**
 * Generated by orval v6.28.2 üç∫
 * Do not edit manually.
 * OpenAPI definition
 * OpenAPI spec version: v0
 */
import {
  useMutation,
  useQuery,
} from '@tanstack/vue-query'
import type {
  MutationFunction,
  QueryFunction,
  QueryKey,
  UseMutationOptions,
  UseMutationReturnType,
  UseQueryOptions,
  UseQueryReturnType,
} from '@tanstack/vue-query'
import {
  unref,
} from 'vue'
import type {
  MaybeRef,
} from 'vue'
import type {
  ExecuteParams,
} from '../../models'
import { customInstance } from '../../mutator/custom-instance'
import type { ErrorType } from '../../mutator/custom-instance'

type AwaitedInput<T> = PromiseLike<T> | T

      type Awaited<O> = O extends AwaitedInput<infer T> ? T : never

export function execute(params: MaybeRef<ExecuteParams>) {
  params = unref(params)

  return customInstance<void>(
    { url: `/api-v1/proxy/execute`, method: 'POST', params: unref(params),
    },
  )
}

export function getExecuteMutationOptions<TError = ErrorType<unknown>, TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof execute>>, TError, { params: ExecuteParams }, TContext> }): UseMutationOptions<Awaited<ReturnType<typeof execute>>, TError, { params: ExecuteParams }, TContext> {
  const { mutation: mutationOptions } = options ?? {}

  const mutationFn: MutationFunction<Awaited<ReturnType<typeof execute>>, { params: ExecuteParams }> = (props) => {
    const { params } = props ?? {}

    return execute(params)
  }

  return { mutationFn, ...mutationOptions }
}

export type ExecuteMutationResult = NonNullable<Awaited<ReturnType<typeof execute>>>

export type ExecuteMutationError = ErrorType<unknown>

export function useExecute<TError = ErrorType<unknown>, TContext = unknown>(options?: { mutation?: UseMutationOptions<Awaited<ReturnType<typeof execute>>, TError, { params: ExecuteParams }, TContext> }): UseMutationReturnType<
        Awaited<ReturnType<typeof execute>>,
        TError,
        { params: ExecuteParams },
        TContext
      > {
  const mutationOptions = getExecuteMutationOptions(options)

  return useMutation(mutationOptions)
}
export function healthcheck(signal?: AbortSignal) {
  return customInstance<string>(
    { url: `/api-v1/proxy/healthcheck`, method: 'GET', signal,
    },
  )
}

export function getHealthcheckQueryKey() {
  return ['api-v1', 'proxy', 'healthcheck'] as const
}

export function getHealthcheckQueryOptions<TData = Awaited<ReturnType<typeof healthcheck>>, TError = ErrorType<unknown>>(options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>> }) {
  const { query: queryOptions } = options ?? {}

  const queryKey = getHealthcheckQueryKey()

  const queryFn: QueryFunction<Awaited<ReturnType<typeof healthcheck>>> = ({ signal }) => healthcheck(signal)

  return { queryKey, queryFn, ...queryOptions } as UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>
}

export type HealthcheckQueryResult = NonNullable<Awaited<ReturnType<typeof healthcheck>>>
export type HealthcheckQueryError = ErrorType<unknown>

export function useHealthcheck<TData = Awaited<ReturnType<typeof healthcheck>>, TError = ErrorType<unknown>>(options?: { query?: Partial<UseQueryOptions<Awaited<ReturnType<typeof healthcheck>>, TError, TData>> }): UseQueryReturnType<TData, TError> & { queryKey: QueryKey } {
  const queryOptions = getHealthcheckQueryOptions(options)

  const query = useQuery(queryOptions) as UseQueryReturnType<TData, TError> & { queryKey: QueryKey }

  query.queryKey = unref(queryOptions).queryKey as QueryKey

  return query
}
